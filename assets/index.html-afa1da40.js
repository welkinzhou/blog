import{_ as n,o as s,c as a,h as p}from"./app-fdc7c009.js";const t="/blog/assets/牛顿法求平方根-a1f0b541.png",e="/blog/assets/有理数运算-f8e073ce.png",c={},o=p(`<h2 id="sicp" tabindex="-1"><a class="header-anchor" href="#sicp" aria-hidden="true">#</a> SICP</h2><p><strong>scheme 语法：</strong></p><p>scheme 都是前缀运算，例如 <code>(+ 2 3)</code>，我们平常用的一般是中缀调用 <code>2 + 3</code>。前缀调用的好处是，可以实现不定参数调用，如 <code>(+ 2 3 4)</code>，平常三个数的加法需要 <code>2 + 3 + 4</code>。</p><p>scheme 中小括号很常见，上述前缀调用中，如果不使用小括号，调用多个参数时，表达式的界限就很难确定。</p><p>scheme 中使用 define 来定义变量，<code>(define size 2)</code> 这样 size 就和 2 关联上了，就可以把 size 当做 2 来使用，也可以定义一个函数 <code>(define (square x) (* x x )</code>。</p><p>scheme 也有分支控制语句，<code>cond</code>，例如下述是一个求绝对值的方法</p><div class="language-lisp line-numbers-mode" data-ext="lisp"><pre class="language-lisp"><code><span class="token punctuation">(</span><span class="token car">define</span> <span class="token punctuation">(</span><span class="token car">abs</span> x<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token keyword">cond</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token car">&gt;</span> x <span class="token number">0</span><span class="token punctuation">)</span> x<span class="token punctuation">)</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token car">=</span> x <span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token car">&lt;</span> x <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token car">-</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述写法类似于 JS 中的 switch 语句。日常编码中，if 这样两个分支的控制语句会更常见一点，scheme 中也有对应的实现方式，一种是使用 cond 加 else（else 类似 JS 中的 default，前面所有的条件都不匹配就会执行 else ），另一种就是 if ：</p><div class="language-scheme line-numbers-mode" data-ext="scheme"><pre class="language-scheme"><code><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> x<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token keyword">cond</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;</span> x <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">-x</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">(</span><span class="token keyword">else</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> x<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> x <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token punctuation">(</span><span class="token operator">-</span> x<span class="token punctuation">)</span>
      x<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>逻辑运算，and，or，和 not 也是存在的。</p><ul><li><code>(and e1&gt; ... &lt;en&gt;)</code> 使用 and 对 e1 到 en 的表达式依次求值，存在一个为假，就不再继续（短路运算），如果前面全部为真，and 的结果和 en 表达式结果相同。</li><li><code>(or &lt;e1&gt; ... &lt;en&gt;)</code> 和 and 运算类似，or 也会从左到右依次求值，存在一个为真 or 的结果就是这个表达式的结果，全部为假，or 的结果就是假。</li><li><code>(not &lt;e&gt;)</code> not 表达式的值，是对 e 取反的结果</li></ul><p>终端命令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>(load &quot;sample.scm&quot;) -- 加载本地文件，这样就可以运行文件中编写的代码了
(exit) -- 退出 scheme
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="第一章" tabindex="-1"><a class="header-anchor" href="#第一章" aria-hidden="true">#</a> 第一章</h3><h4 id="应用序求值和正则序求值" tabindex="-1"><a class="header-anchor" href="#应用序求值和正则序求值" aria-hidden="true">#</a> 应用序求值和正则序求值：</h4><p>所谓应用序求值，即先求值，再将所得值带入表达式。</p><p>正则序，也即不先求值，而是把值展开为所代表的表达式，将表达式完全展开后再求值。</p><p>例如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
c <span class="token operator">=</span> b <span class="token operator">*</span> b<span class="token punctuation">;</span>

<span class="token comment">// 应用序求解模拟 ： a==1 ==&gt; b = 2 ==&gt; c = 2 * 2 = 4</span>
<span class="token comment">// 正则序求解模拟 ： a==1 ==&gt; b = a + 1 ==&gt; c = (a + 1) * (a + 1) = 2 * 2 = 4</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，正则序的求值过程中，存在大量基础表达式计算的重复，上述例子中 <code>(a + 1)</code> 就会被重复计算。</p><p>习题中的 1.4 更清楚的描述了正则序和应用序的另一个区别：</p><div class="language-scheme line-numbers-mode" data-ext="scheme"><pre class="language-scheme"><code><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">p</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">p</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">test</span> x y<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> x <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token number">0</span>
      y<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token function">test</span> <span class="token number">0</span> <span class="token punctuation">(</span><span class="token function">p</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码在正则序中，由于不会立即求值，会先运行 test 方法，发现满足第一个条件，返回结果 0。在应用序中，程序会卡死，因为 <code>(p)</code> 会一直重复调用自身，这样程序就一直没有办法走下去。</p><p>Lisp 中也存在<strong>高阶函数</strong>：</p><div class="language-scheme line-numbers-mode" data-ext="scheme"><pre class="language-scheme"><code><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">a-plus-abs-b</span> a b<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&gt;</span> b <span class="token number">0</span><span class="token punctuation">)</span> + -<span class="token punctuation">)</span> a b<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>乍一看，上述代码有一点不明白什么意思，当你了解了 Lisp 也可以使用高阶函数，就会豁然开朗。if 语句会根据 b 是否大于零来返回不同的操作符，在对后面的 a b 进行相应运算。</p><h4 id="块结构" tabindex="-1"><a class="header-anchor" href="#块结构" aria-hidden="true">#</a> 块结构</h4><p>下面是牛顿法求 2 的平方根的过程，首先从 1 开始猜测，1 肯定不满足条件，接着优化这猜测，取 2 和 1 的平均值，重复这个过程直到结果足够好。更通用的描述，x 是我们需要求解的值，首先对 x 的平方根选择一个猜测值 y（1），如果猜测不符合预期，下一步更新猜测值为 <code>y = (y + x / y)/2</code></p><img src="`+t+`" alt="运算描述" style="zoom:40%;"><p>使用代码可以抽象为下面几个过程</p><div class="language-scheme line-numbers-mode" data-ext="scheme"><pre class="language-scheme"><code><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">average</span> x y<span class="token punctuation">)</span>  <span class="token comment">; 定义一个求平均值的过程</span>
  <span class="token punctuation">(</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token operator">+</span> x y<span class="token punctuation">)</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">improve</span> guess x<span class="token punctuation">)</span> <span class="token comment">; 更新猜测值</span>
  <span class="token punctuation">(</span><span class="token function">average</span> guess <span class="token punctuation">(</span><span class="token operator">/</span> x guess<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">good-enough?</span> guess x<span class="token punctuation">)</span> <span class="token comment">; 判断是否符合要求</span>
  <span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token builtin">square</span> guess<span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">0.001</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sqrt-iter</span> guess x<span class="token punctuation">)</span> <span class="token comment">; 主体函数，guess 是我们猜测的平方根，x 是需要求解平方根的值</span>
  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">good-enough?</span> guess x<span class="token punctuation">)</span> <span class="token comment">; 判断是否符合我们给定的平方根条件</span>
      guess
      <span class="token punctuation">(</span><span class="token function">sqrt-iter</span> <span class="token punctuation">(</span><span class="token function">improve</span> guess x<span class="token punctuation">)</span> <span class="token comment">; 不符合就递归调用</span>
                 x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sqrt</span> x<span class="token punctuation">)</span> <span class="token comment">; 从 1 开始猜</span>
  <span class="token punctuation">(</span><span class="token function">sqrt-iter</span> <span class="token number">1.0</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码，拆分了几个基础过程，并将其组合起来形成了一个完整功能。这种代码模式很有函数式编程的风格，很好理解。所有方法全部定义在全局，在代码量增加后可能会出现一些问题。比如说 improve 这个方法，很难保证在别的功能中，不会有一个类似的更新值功能，自然我们更想也使用 improve 名字（经常想名字很烦的）。定义在全局的方法，重名就会导致编译时不知道需要用哪个函数。所以这些服务于一个功能的方法，我们希望能局部化。</p><div class="language-scheme line-numbers-mode" data-ext="scheme"><pre class="language-scheme"><code><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sqrt</span> x<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">good-enough?</span> guess x<span class="token punctuation">)</span>
     <span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token punctuation">(</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token builtin">square</span> guess<span class="token punctuation">)</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">0.001</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">improve</span> guess x<span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token function">average</span> guess <span class="token punctuation">(</span><span class="token operator">/</span> x guess<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sqrt-iter</span> guess x<span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">good-enough?</span> guess x<span class="token punctuation">)</span>
        guess
        <span class="token punctuation">(</span><span class="token function">sqrt-iter</span> <span class="token punctuation">(</span><span class="token function">improve</span> guess x<span class="token punctuation">)</span>
                   x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token function">sqrt-iter</span> <span class="token number">1.0</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样 <code>good-enough?</code> 这些方法就被约束在 <code>sqrt</code>，同时可以发现，这些方法中使用的 x 都是同一个 x，这样我们也可以省略内部方法的 x 参数，直接让它们使用 <code>sqrt</code> 接收的 x 就行了，这就是常说的<code>词法作用域</code>。通过词法作用域，我们就可以将功能拆分成一个个 <code>块结构</code>，这种思想来自于 Algol 60。</p><h4 id="_1-2-线性的递归和迭代" tabindex="-1"><a class="header-anchor" href="#_1-2-线性的递归和迭代" aria-hidden="true">#</a> 1.2 线性的递归和迭代</h4><p>如果需要实现一个阶乘的方法，数学上的定义很简单。</p><blockquote><p>n! = n _ (n -1) _ (n - 2) ... * 1</p><p>​ = n _ ( (n -1) _ (n - 2) ... * 1 )</p><p>​ = n * (n - 1)!</p></blockquote><p>这样可以简单写出一个方法</p><div class="language-scheme line-numbers-mode" data-ext="scheme"><pre class="language-scheme"><code><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">factorial</span> n<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token number">1</span>
      <span class="token punctuation">(</span><span class="token operator">*</span> n <span class="token punctuation">(</span><span class="token function">factorial</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>考察这样一个过程，如果我们计算 (factorial 4)，就会有一下过程</p><div class="language-scheme line-numbers-mode" data-ext="scheme"><pre class="language-scheme"><code><span class="token punctuation">(</span><span class="token function">factorial</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token function">factorial</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token function">factorial</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token function">factorial</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">2</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直观感受上就能看出一定要展开到随后一级，才能收缩计算，也就是这个方法需要保存一个延迟执行的计算链条。这样的一个<code>递归计算过程</code>可能需要消耗很多空间，当没有达到边界条件时，展开的计算结果没有返回，所以需要一直保持函数的空间。</p><p>还有一种思考方式，我们定义阶乘过程是，先使用 1 乘上 2，再将得到的结果乘上 3，以此类推，知道乘到 n。</p><p>考察整个过程，可以叫过程分为两部分，一部分是乘法操作，记做 product，一部分是循环控制，记做 counter。整个变化过程规律如下：</p><blockquote><p>product &lt;- product * counter</p><p>counter &lt;- counter + 1</p></blockquote><p>这样就可以写出一下方法：</p><div class="language-lisp line-numbers-mode" data-ext="lisp"><pre class="language-lisp"><code><span class="token punctuation">(</span><span class="token car">define</span> <span class="token punctuation">(</span><span class="token car">factorial</span> n<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token car">fact-iter</span> <span class="token number">1</span> <span class="token number">1</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token car">define</span> <span class="token punctuation">(</span><span class="token car">fact-iter</span> product counter max-count<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token car">&gt;</span> counter max-count<span class="token punctuation">)</span>
      product
      <span class="token punctuation">(</span><span class="token car">fact-iter</span> <span class="token punctuation">(</span><span class="token car">*</span> product counter<span class="token punctuation">)</span>
                 <span class="token punctuation">(</span><span class="token car">+</span> counter <span class="token number">1</span><span class="token punctuation">)</span>
                 max-count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 <code>fact-iter</code> 中，每次运算我们都会更新参数对应的值。这样当参数传入下一次调用的方法中，外层函数中的值，就已经和下一轮函数的值联系断开了。这样也没有必要保存上一次调用的 context，空间上每次只需要保留一个函数的空间。例如：</p><div class="language-lisp line-numbers-mode" data-ext="lisp"><pre class="language-lisp"><code><span class="token punctuation">(</span><span class="token car">factorial</span> <span class="token number">6</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token car">fact-iter</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">6</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token car">fact-iter</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">6</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token car">fact-iter</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">6</span><span class="token punctuation">)</span>
...
<span class="token punctuation">(</span><span class="token car">fact-iter</span> <span class="token number">720</span> <span class="token number">7</span> <span class="token number">6</span><span class="token punctuation">)</span>
<span class="token number">720</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果仔细思考，无论那个时刻，fact-iter 调用过程中，都包含了每个状态的完整描述。从计算的角度看，这是一个迭代的计算过程。也就是这个版本的 factorial，在递归过程中封装了一个迭代计算。对于这种迭代计算过程，完全可以用常数空间去描述，也就是常说的 <code>尾递归优化</code>。</p><h5 id="_1-2-2-树形递归" tabindex="-1"><a class="header-anchor" href="#_1-2-2-树形递归" aria-hidden="true">#</a> 1.2.2 树形递归</h5><p>对于斐波那契数列的计算，从定义看是一个常见的树形递归。</p><div class="language-lisp line-numbers-mode" data-ext="lisp"><pre class="language-lisp"><code><span class="token punctuation">(</span><span class="token car">define</span> <span class="token punctuation">(</span><span class="token car">fib</span> n<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token keyword">cond</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token car">=</span> n <span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span>
    		<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token car">=</span> n <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span>
    		<span class="token punctuation">(</span><span class="token car">else</span> <span class="token punctuation">(</span><span class="token car">+</span> <span class="token punctuation">(</span><span class="token car">fib</span> <span class="token punctuation">(</span><span class="token car">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                 <span class="token punctuation">(</span><span class="token car">fib</span> <span class="token punctuation">(</span><span class="token car">-</span> n <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到描述很简单，定义两个边界条件 <code>n = 0</code> 和 <code>n = 1</code>，其他情况通过 <code>f(n) = f(n-1) + f(n-2)</code> 来递归计算。也就是每次计算会展开两个分支，f(n -1) 和 f(n - 2)，知道最终展开到叶节点 f(0) 和 f(1) 的情况。</p><p>看起来描述很简单，但是计算起来非常糟糕，全是冗余计算。比如，f(n -1) 的计算过程中，本身就包含 f(n)，更不用说最后的展开结果，全是 f(0) 和 f(1)，这些计算都会被重复计算。</p><p>对于这种情况，我们当然也会想到迭代计算：</p><div class="language-lisp line-numbers-mode" data-ext="lisp"><pre class="language-lisp"><code><span class="token punctuation">(</span><span class="token car">define</span> <span class="token punctuation">(</span><span class="token car">fib</span> n<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token car">fib-iter</span> <span class="token number">0</span> <span class="token number">1</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token car">define</span> <span class="token punctuation">(</span><span class="token car">fib-iter</span> a b max-count<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token car">=</span> max-count <span class="token number">0</span><span class="token punctuation">)</span>
      a
      <span class="token comment">;更新 n-1(b) 变成 n-2，然后计算 n-1 = a + b</span>
      <span class="token punctuation">(</span><span class="token car">fib-iter</span> b <span class="token punctuation">(</span><span class="token car">+</span> a b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token car">-</span> max-count <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="第二章" tabindex="-1"><a class="header-anchor" href="#第二章" aria-hidden="true">#</a> 第二章</h3><h4 id="什么是数据" tabindex="-1"><a class="header-anchor" href="#什么是数据" aria-hidden="true">#</a> 什么是数据</h4><p>例如我们需要计算有理数，首先需要在数据层面定义什么是有理数。我想每个人对于数的认识，都是一步一步来的。首先是正整数，然后加上一个零，或许还有分数，随后是分数。那具体要怎么表示有理数，统一的方式就是使用分数的方式。</p><p>所以这里我们假设，已经有了通过分子，和分母来构造出一个有理数的方法，同时我们假设，还有两个方法可以分别去取得有理数的分子和分母。例：</p><div class="language-lisp line-numbers-mode" data-ext="lisp"><pre class="language-lisp"><code><span class="token punctuation">(</span><span class="token car">make-rat</span> &lt;n&gt; &lt;d&gt;<span class="token punctuation">)</span> 返回一个有理数，分子是整数 n，分母是整数 d
<span class="token punctuation">(</span><span class="token car">numer</span> &lt;x&gt;<span class="token punctuation">)</span> 返回有理数 x 的分子
<span class="token punctuation">(</span><span class="token car">denom</span> &lt;x&gt;<span class="token punctuation">)</span> 返回有理数 x 的分母
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着我们需要对我们的假设进行约束，如果满足约束，那这个实现就是可行的。</p><img src="`+e+`" alt="运算描述" style="zoom:33%;"><p>代码描述如下：</p><div class="language-lisp line-numbers-mode" data-ext="lisp"><pre class="language-lisp"><code><span class="token punctuation">(</span><span class="token car">define</span> <span class="token punctuation">(</span><span class="token car">add-rat</span> x y<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token car">make-rat</span> <span class="token punctuation">(</span><span class="token car">+</span>
             <span class="token punctuation">(</span><span class="token car">*</span> <span class="token punctuation">(</span><span class="token car">numer</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token car">denom</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span>
             <span class="token punctuation">(</span><span class="token car">*</span> <span class="token punctuation">(</span><span class="token car">denom</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token car">numer</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">; 构造新的分子</span>
            <span class="token punctuation">(</span><span class="token car">*</span> <span class="token punctuation">(</span><span class="token car">denom</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token car">denom</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">; 构造新的分母</span>

<span class="token punctuation">(</span><span class="token car">define</span> <span class="token punctuation">(</span><span class="token car">sub-rat</span> x y<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token car">make-rat</span> <span class="token punctuation">(</span><span class="token car">-</span>
             <span class="token punctuation">(</span><span class="token car">*</span> <span class="token punctuation">(</span><span class="token car">numer</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token car">denom</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span>
             <span class="token punctuation">(</span><span class="token car">*</span> <span class="token punctuation">(</span><span class="token car">denom</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token car">numer</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">; 构造新的分子</span>
            <span class="token punctuation">(</span><span class="token car">*</span> <span class="token punctuation">(</span><span class="token car">denom</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token car">denom</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">; 构造新的分母</span>
<span class="token punctuation">(</span><span class="token car">define</span> <span class="token punctuation">(</span><span class="token car">mul-rat</span> x y<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token car">make-rat</span> <span class="token punctuation">(</span><span class="token car">*</span> <span class="token punctuation">(</span><span class="token car">numer</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token car">numer</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">(</span><span class="token car">*</span> <span class="token punctuation">(</span><span class="token car">denom</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token car">denom</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token car">define</span> <span class="token punctuation">(</span><span class="token car">div-rat</span> x y<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token car">make-rat</span> <span class="token punctuation">(</span><span class="token car">*</span> <span class="token punctuation">(</span><span class="token car">numer</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token car">denom</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">(</span><span class="token car">*</span> <span class="token punctuation">(</span><span class="token car">denom</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token car">numer</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token car">define</span> <span class="token punctuation">(</span><span class="token car">equal-rat</span> x y<span class="token punctuation">)</span>  <span class="token comment">; 也既十字交叉相乘</span>
  <span class="token punctuation">(</span><span class="token car">=</span> <span class="token punctuation">(</span><span class="token car">*</span> <span class="token punctuation">(</span><span class="token car">numer</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token car">denom</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span>
     <span class="token punctuation">(</span><span class="token car">*</span> <span class="token punctuation">(</span><span class="token car">numer</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token car">denom</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>序对</strong></p><p>为了构造有理数上面的三个基础方法，引入序对的概念，类似一个长度为 2 的元组。通过 cons 方法构造一个序对，方法接受两个参数，</p><p>通过 car 和 cdr 可以分别取出 cons 中保存的两个参数，类似于 head 和 tail 方法。</p><div class="language-lisp line-numbers-mode" data-ext="lisp"><pre class="language-lisp"><code><span class="token punctuation">(</span><span class="token car">define</span> x cons<span class="token punctuation">(</span><span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token car">car</span> x<span class="token punctuation">)</span> ----&gt; <span class="token number">1</span>
<span class="token punctuation">(</span><span class="token car">cdr</span> x<span class="token punctuation">)</span> ----&gt; <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样我们就可以实现那三个有理数相关的基础方法了</p><div class="language-lisp line-numbers-mode" data-ext="lisp"><pre class="language-lisp"><code><span class="token punctuation">(</span><span class="token car">define</span> <span class="token punctuation">(</span><span class="token car">make-rat</span> n d<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">cons</span> n d<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token car">define</span> <span class="token punctuation">(</span><span class="token car">numer</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token car">car</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token car">define</span> <span class="token punctuation">(</span><span class="token car">denom</span> x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token car">cdr</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对照我们的约束条件，可以满足。虽然这样表示还是有问题，比如说是否需要约分，是计算时候约分还是取值时候约分，但是功能是没有问题的。</p><p>可能这种表现形式，和我们熟悉的方式有点不一样，通过一个复合数据类型表示一个数。也正是这种情况，促使我们思考数据的本质。实际上表现形式并不重要，无论你如果表示，只要最终能实现我们需要的结果就是可行的。</p><p>我为什么喜欢 JS 也是因为这个原因（我讨厌强类型约束），实际上我们可以不把数据看成一个数，它可以是任何东西。make-rat 中可以传入任何数据类型，car 和 cdr 都可以得到我们想要的结果。在这个过程中，数据本身并不重要。只要仔细考察过，过程是可靠的，我们甚至可以直接使用过程作为参数或者变量，进行运算化简。</p><p>假设有这样一个函数，调用就返回一个固定值，可不可以将这个函数看作一个常量？又有另一个函数，接收一个值，返回值有一个 map 方法可以修改这个值，还有一个 get 方法每一次调用，就将内部存储的值返回出去，这个函数可不可以看作一个变量？用 JS 描述，这样两种行为唯一的区别就在于，变量使用时直接只用变量名 variable，函数需要调用 variable()，除开形式上的差异，并不能从表现上区分这两种情况。函数式编程最终是将过程（函数）组合起来，这样也可以在最后一步需要时才执行，也就可以做到惰性运算。</p><p>习惯了命令式编程，可能会觉得接下来的讨论毫无意义。我们习惯了变量的概念，会难以理解 Haskell 中的 id 函数（接受一个值，返回这个值），为什么要做这种冗余的事情：</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token builtin">id</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">id</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>每个函数（或者说态射）返回一个新值，将所有过程在最后组合起来就能得到一个结果。</p><p>这里忽略了变量，将着眼点放在函数上，其实也就是常说的 PointFree。我也不知道这种思考对于编程到底有什么好处，它只是一点思考形式上的区别。非 PointFree 的模式下，思考的中心在变量身上，对变量进行一步步的变形。PointFree 的着眼点，更多在于过程和类型。就像物理推导中，只要量纲等效，过程可靠，并不需要关心使用的具体使用的是什么单位。</p><p>这些逻辑上的抽象，并不是在告诉你，孰优孰劣。我个人觉得编程上，没有优劣，只有适合与不适合。在实际的工作中，我也会懒得进行细致的拆分，写一个很长很长的函数，某些情况下，这反而是一种高效的手段。拆分代码片段，最主要的作用，是减轻阅读的心智负担，当然习惯了代码块，会觉得这种处理方式效率更高。</p><p>对于新手（不管是编程，还是其他方面），如何对一个过程进行层次化分解与重新复合，是一项让人着迷，同时又深感似是而非的工作。例如，高中解立体几何，做合适的辅助线，将问题拆解成我们熟悉范式，是一种高效的手段。难点在于，如何做辅助线。良师的循循善诱，也就是在合适的角度，去引导拆分每一步，进而让整个解题思路豁然开朗。对比到编程上，拆分代码块，也需要做到每一步目的清晰，并且能引导阅读的人，立马明白下一步的思路。如果不做拆分，可能需要读完整体代码才能理解。如果粒度太细，又会让阅读的人过多的思考，这一步有没有什么别的意义，在阅读下一步代码时候还需要记住之前的工作，其实也不是太好，需要在合适的时候，进行组合。对细粒度的代码，进行组合，使之形成一个新的代码块，是一个很考究的过程。代码块的实现过程结束，就可以变成黑箱，不必关心它的实现细节，只关心它与其他代码块的相互影响。</p>`,82),u=[o];function l(i,k){return s(),a("div",null,u)}const d=n(c,[["render",l],["__file","index.html.vue"]]);export{d as default};
