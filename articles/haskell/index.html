<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.66">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/images/logo.jpg"><title>守拙</title><meta name="description" content="welkin 的互联网小窝">
    <link rel="preload" href="/blog/assets/style-65ae1279.css" as="style"><link rel="stylesheet" href="/blog/assets/style-65ae1279.css">
    <link rel="modulepreload" href="/blog/assets/app-fdc7c009.js"><link rel="modulepreload" href="/blog/assets/index.html-c8f4ef9a.js"><link rel="modulepreload" href="/blog/assets/index.html-bf27224c.js"><link rel="prefetch" href="/blog/assets/index.html-c65d6296.js" as="script"><link rel="prefetch" href="/blog/assets/css.html-0ce2c90b.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-f13a5230.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-6c9ebd72.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-253e4e3b.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-aeead59c.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-5ca8d4ca.js" as="script"><link rel="prefetch" href="/blog/assets/404.html-f9875e7b.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-0e9a6e06.js" as="script"><link rel="prefetch" href="/blog/assets/css.html-73f9814d.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-afa1da40.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-a624acd0.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-968f6d6d.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-9d88ff26.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-e08312ff.js" as="script"><link rel="prefetch" href="/blog/assets/404.html-fdaa90d3.js" as="script"><link rel="prefetch" href="/blog/assets/giscus-765fdce2.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/blog/" class=""><img class="logo" src="/blog/images/logo.jpg" alt="守拙"><span class="site-name can-hide">守拙</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/blog/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/welkinzhou/blog" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/blog/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/welkinzhou/blog" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading"> <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog/articles/haskell/#基础" class="router-link-active router-link-exact-active sidebar-item" aria-label="基础"><!--[--><!--]--> 基础 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/articles/haskell/#类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="类型"><!--[--><!--]--> 类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/articles/haskell/#函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="函数"><!--[--><!--]--> 函数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/articles/haskell/#递归" class="router-link-active router-link-exact-active sidebar-item" aria-label="递归"><!--[--><!--]--> 递归 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/articles/haskell/#模块" class="router-link-active router-link-exact-active sidebar-item" aria-label="模块"><!--[--><!--]--> 模块 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/articles/haskell/#types-构造" class="router-link-active router-link-exact-active sidebar-item" aria-label="Types 构造"><!--[--><!--]--> Types 构造 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><p><strong>常用操作：</strong> Haskell 的文件使用 .hs 结尾。Haskell 提供一个运行环境 - ghci，使用命令 <code>ghci</code> 启用，可以进行简单的交互， 也可以使用命令 <code>:l fileName.hs</code>，加载 Haskell 文件，<code>ghc</code> 是编译 .hs 文件的命令。</p><h3 id="基础" tabindex="-1"><a class="header-anchor" href="#基础" aria-hidden="true">#</a> 基础</h3><p>Haskell 中函数有最高的优先级，并且函数调用传参可以不用小括号，并且有前缀和中缀的调用方式。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token builtin">succ</span> <span class="token number">8</span> <span class="token comment">--succ是一个函数，获得参数的后继，如8 -&gt; 9 函数名加空格调用,也可以加小括号</span>
<span class="token builtin">succ</span> <span class="token number">9</span> <span class="token operator">+</span> <span class="token builtin">max</span> <span class="token number">10</span> <span class="token number">12</span> <span class="token operator">+</span> <span class="token number">1</span>
<span class="token comment">-- 相当于</span>
<span class="token punctuation">(</span><span class="token builtin">succ</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token builtin">max</span> <span class="token number">10</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
<span class="token comment">-- div 除法函数，下面是前缀调用</span>
<span class="token builtin">div</span> <span class="token number">90</span> <span class="token number">10</span>
<span class="token comment">-- 也可以使用下面的中缀调用, 中缀调用要将函数名使用反引号(`)包裹</span>
<span class="token number">90</span> <span class="token operator">`div`</span> <span class="token number">10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Haskell 有条件语句，但是 else 不能省略</p><div class="language-handlebars line-numbers-mode" data-ext="handlebars"><pre class="language-handlebars"><code>doubleSmallNumber x = if x &gt; 100 then x else x * 2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Haskell 中有列表，列表是一种单类型（homogeneous）的数据结构，只能存放多个单一类型的数据，不能数字和字符放一起。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token hvariable">someNumbers</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用 ++ 拼接两个列表，同时 Haskell 中没有字符串，字符串相当于一组字符组成的列表, &quot;Tom&quot; 等效于 [&quot;T&quot;, &quot;o&quot;, &quot;m&quot;]，++运算符 是遍历第一个列表的（也就是++左边的列表），如果数据太大会很慢。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token comment">-- expected [1, 2, 3, 4]</span>
<span class="token string">&quot;hello&quot;</span> <span class="token operator">++</span> <span class="token string">&quot; &quot;</span> <span class="token operator">++</span> <span class="token string">&quot;world&quot;</span><span class="token comment">-- expected &quot;hello world&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>：运算符，可以将一个元素插入到列表表头。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token number">5</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token comment">-- excepted [5, 1, 2]</span>
<span class="token comment">-- 需要注意，实际上 [1, 2, 3] 是 1: 2 :3 :[]的语法糖</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果需要获取列表中的某一个元素，可以使用 !! 运算符，相当于数组下标。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token string">&quot;Steve Buscemi&quot;</span> <span class="token operator">!!</span> <span class="token number">6</span> <span class="token comment">--excepted &quot;B&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="类型" tabindex="-1"><a class="header-anchor" href="#类型" aria-hidden="true">#</a> 类型</h3><p>Haskell 是强类型语言，基本运算可以通过参数推断出来，也可以手动指定类型，非常类似 TS，但是 Haskell 的类型声明更加强大。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token hvariable">removeNonUppercase</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>  <span class="token comment">-- 这是 removeNonUppercase 的函数声明，输入 [Char]，输出也是 [Char]</span>
<span class="token hvariable">removeNonUppercase</span> <span class="token hvariable">st</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token hvariable">c</span> <span class="token operator">|</span> <span class="token hvariable">c</span> <span class="token operator">&lt;-</span> <span class="token hvariable">st</span><span class="token punctuation">,</span> <span class="token hvariable">c</span> <span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token char string">&#39;A&#39;</span><span class="token operator">..</span><span class="token char string">&#39;Z&#39;</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token comment">-- 下面是具体实现</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一个多参数函数的声明示例，可以看到 Haskell 中并没有像 TS 一样，将传参使用括号包裹起来，如 <strong>(a:number, b:number, c:number) =&gt; number</strong>。</p><p>Haskell 是函数式编程语言，必然返回一个值。这样除了最后一个 Int，其他的都是参数的类型约束。更主要的原因是，Haskell 中的函 数都是 Curried Function。标准的函数式编程，都是接受一个值，返回一个值，函数也可以看作一个值。</p><p>:t 命令，可以返回相应的类型。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token hvariable">addThree</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">addThree</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token hvariable">z</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span> <span class="token operator">+</span> <span class="token hvariable">z</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Haskell 中也存在类似泛型(generic) 的概念，叫做类型变量（Type variables）。和 TS 不同，Haskell 中通常使用小写 a,b,c,d... 来表示泛型。</p><p>如内置的 head 函数，用来获取 list 的第一个元素，list 中放置的元素类型是不确定的，所以这里使用 a 来表示一个不定的类型。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">head</span>
<span class="token builtin">head</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>使用类型变量，可以是函数的类型声明更加强大，可以写出通用性更高的，与类型无关的函数，使用到类型变量的函数又叫**<em>多态函 数</em>**。</p><h4 id="typeclass" tabindex="-1"><a class="header-anchor" href="#typeclass" aria-hidden="true">#</a> Typeclass</h4><p>型别定义行为的接口，如果一个型别属于某 Typeclass，那它必实现了该 Typeclass 所描述的行为。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token operator">:</span><span class="token hvariable">t</span> <span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里我们见到个新东西：<code>=&gt;</code> 符号。它左边的部分叫做型别约束。我们可以这样阅读这段型别声明：&quot;相等函数取两个相同型别的值作 为参数并回传一个布尔值，而这两个参数的型别同在 Eq 类之中(即型别约束)&quot;。</p><p>可以简单理解为，Eq 是一个泛型的约束条件，这里我们需要用到一个泛型 a， Eq 约束了 a 范围，只要能使用 == 判断是否相等的类型 ，都是属于 Eq。</p><h3 id="函数" tabindex="-1"><a class="header-anchor" href="#函数" aria-hidden="true">#</a> 函数</h3><h4 id="模式匹配-pattern-matching" tabindex="-1"><a class="header-anchor" href="#模式匹配-pattern-matching" aria-hidden="true">#</a> 模式匹配 (Pattern matching)</h4><p>下面是一个模式匹配的例子</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token hvariable">sayMe</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Integral</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">sayMe</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token string">&quot;One!&quot;</span>
<span class="token hvariable">sayMe</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token string">&quot;Two!&quot;</span>
<span class="token hvariable">sayMe</span> <span class="token number">3</span> <span class="token operator">=</span> <span class="token string">&quot;Three!&quot;</span>
<span class="token hvariable">sayMe</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token string">&quot;Four!&quot;</span>
<span class="token hvariable">sayMe</span> <span class="token number">5</span> <span class="token operator">=</span> <span class="token string">&quot;Five!&quot;</span>
<span class="token hvariable">sayMe</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token string">&quot;Not between 1 and 5&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>sayMe 从上到下进行匹配，如果匹配到就执行，并忽略下面的模式，最后的 x 代表一个匹配任何情况的默认执行，没有默认执行，如果 没有匹配到，就会报错。</p><p>这样来看，模式匹配和 switch 语句好像区别不大，看起来平平无奇，下面来看一个更厉害的例子。</p><p>如果现在需要实现一个二维矢量相加的函数（x, y 分别相加），最基础的写法可能是这样。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token hvariable">addVectors</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">addVectors</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">fst</span> <span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token builtin">fst</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token builtin">snd</span> <span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token builtin">snd</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果使用模式匹配</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token hvariable">addVectors</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">addVectors</span> <span class="token punctuation">(</span><span class="token hvariable">x1</span><span class="token punctuation">,</span> <span class="token hvariable">y1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">x2</span><span class="token punctuation">,</span> <span class="token hvariable">y2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x1</span> <span class="token operator">+</span> <span class="token hvariable">x2</span><span class="token punctuation">,</span> <span class="token hvariable">y1</span> <span class="token operator">+</span> <span class="token hvariable">y2</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>非常简单，而且清晰，(x1, y1) (x2, y2) 类似两个元组的泛型，返回一个元组 (x1 + x2, y1 + y2)。</p><p>接下来是一个 list 的求和计算函数</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token builtin">sum</span>&#39; <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">sum</span>&#39; <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token builtin">sum</span>&#39; <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token builtin">sum</span>&#39; <span class="token hvariable">xs</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果是空 list 直接返回 0。</p><p>list 又可以看作 head: tail，将头部的第一个元素，插入到尾部的 list 前。第二个模式的意思就是，list a 的头部是 x，剩下的 list 尾部就是 xs，这样可以通过模式匹配简单的将头部 x 取出来，再递归获取尾部的 sum 结果，并将两者加起来。</p><h4 id="guard" tabindex="-1"><a class="header-anchor" href="#guard" aria-hidden="true">#</a> Guard</h4><p>模式匹配虽然方便，但是只能匹配特定值。</p><p>例如模式匹配的第一个例子，只能 1，2，3，4，5 一个个地匹配，如果是 1 - 10，统一匹配一个结果，剩下的走默认处理，这样就需要 写很多重复的代码。</p><p>这时候就会用 Guard，和模式匹配不同，Guard 不匹配特定条件，而是匹配一个 Boolean 表达式，类似 if 。</p><p>下面是一个计算 BMI，依据你的 BMI 值 (body mass index，身体质量指数)来不同程度地侮辱你的函数。BMI 值即为体重除以身高的平 方。如果小于 18.5，就是太瘦；如果在 18.5 到 25 之间，就是正常；25 到 30 之间，超重；如果超过 30，肥胖。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token hvariable">bmiTell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">bmiTell</span> <span class="token hvariable">weight</span> <span class="token hvariable">height</span>
    <span class="token operator">|</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> <span class="token number">18.5</span> <span class="token operator">=</span> <span class="token string">&quot;You&#39;re underweight, you emo, you!&quot;</span>
    <span class="token operator">|</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> <span class="token number">25.0</span> <span class="token operator">=</span> <span class="token string">&quot;You&#39;re supposedly normal. Pffft, I bet you&#39;re ugly!&quot;</span>
    <span class="token operator">|</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> <span class="token number">30.0</span> <span class="token operator">=</span> <span class="token string">&quot;You&#39;re fat! Lose some weight, fatty!&quot;</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>                 <span class="token operator">=</span> <span class="token string">&quot;You&#39;re a whale, congratulations!&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>bmiTell 是函数名， weight height 是两个参数，注意这里和一般函数的区别。Guard 函数后面直接跟 Guard 的语法，没有使用 = ， 将函数实现和名称，参数连接起来。｜表示一个 Guard 语句的开始，后面跟条件判断，紧跟 = 返回值，otherwise 跟一个默认的处理。</p><p>上述代码中 <strong><em>weight / height ^ 2</em></strong> 被计算了三次，统一个函数体中，计算三次很是浪费，所以有了 <strong><em>where</em></strong> 的语法。</p><p>下面是一个使用 <strong><em>where</em></strong> 优化后的代码</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token hvariable">bmiTell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">bmiTell</span> <span class="token hvariable">weight</span> <span class="token hvariable">height</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">18.5</span> <span class="token operator">=</span> <span class="token string">&quot;You&#39;re underweight, you emo, you!&quot;</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">25.0</span> <span class="token operator">=</span> <span class="token string">&quot;You&#39;re supposedly normal. Pffft, I bet you&#39;re ugly!&quot;</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">30.0</span> <span class="token operator">=</span> <span class="token string">&quot;You&#39;re fat! Lose some weight, fatty!&quot;</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>   <span class="token operator">=</span> <span class="token string">&quot;You&#39;re a whale, congratulations!&quot;</span>
    <span class="token keyword">where</span> <span class="token hvariable">bmi</span> <span class="token operator">=</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里通过 where 提供了一个变量，通过一次计算，在当前函数语句中都可以使用，where 是可以定义多个变量或者函数的。</p><h4 id="let-变量" tabindex="-1"><a class="header-anchor" href="#let-变量" aria-hidden="true">#</a> let 变量</h4><p>通过 where 只能定义一个在函数内部可用的变量，当我们需要跨函数调用就很麻烦。</p><p><code>let</code> 绑定则是个表达式，允许你在任何位置定义局部变量,<code>let</code> 的格式为 <code>let [bindings] in [expressions]</code>。在 <code>let</code> 中绑定的 名字仅对 <code>in</code> 部分可见。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token hvariable">cylinder</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">cylinder</span> <span class="token hvariable">r</span> <span class="token hvariable">h</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token hvariable">sideArea</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span> <span class="token operator">*</span> <span class="token hvariable">h</span>
        <span class="token hvariable">topArea</span> <span class="token operator">=</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span> <span class="token operator">^</span><span class="token number">2</span>
    <span class="token keyword">in</span>  <span class="token hvariable">sideArea</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token hvariable">topArea</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="递归" tabindex="-1"><a class="header-anchor" href="#递归" aria-hidden="true">#</a> 递归</h3><p>递归之于函数式编程，就像循环之于命令式编程。</p><p>理解这两者差别，可以更清楚地理解函数式编程和命令式编程。</p><p>首先从大家更熟悉的命令式编程说起</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述是一个简单的 loop 结构。顾名思义，命令时编程，也就是发布命令，告诉程序每一步做什么，如例子中，声明一个 i ，告诉程序 ，如果 i &lt; 10，就打印 i，并且将 i 加一，再次判断，直到不符合条件。</p><p>接下来看一个典型的递归函数</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token builtin">maximum</span>&#39; <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">maximum</span>&#39; <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;maximum of empty list&quot;</span>
<span class="token builtin">maximum</span>&#39; <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
<span class="token builtin">maximum</span>&#39; <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token hvariable">maxTail</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">maxTail</span>
    <span class="token keyword">where</span> <span class="token hvariable">maxTail</span> <span class="token operator">=</span> <span class="token builtin">maximum</span>&#39; <span class="token hvariable">xs</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里使用了模式匹配，首先空 list，会报错，单个元素的 list，返回 list 的第一个元素，也是唯一一个元素。当 list 中不止一个元 素是，比较 list 的 head，与对 list 的 tail 递归调用 maximum&#39; 结果，取两者中大的值作为结果。</p><p>函数式编程，区别于命令，更像一组描述。在这个过程中，我们既不知道每一步需要操作什么，不知道需要多少步。只是给了每一步可能 需要用到的操作，已经针对不同操作的情景描述。根据这些描述，程序会自动匹配查找操作，并一步步找到结果。这就是函数式编程的魅 力，它不会冷冰冰地告诉你需要怎么做。只会把所有的解决方式告诉你，等待你自己找出通往结果的那条路。</p><h4 id="快速排序" tabindex="-1"><a class="header-anchor" href="#快速排序" aria-hidden="true">#</a> 快速排序</h4><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token hvariable">quicksort</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">quicksort</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">quicksort</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token hvariable">smallerSorted</span> <span class="token operator">=</span> <span class="token hvariable">quicksort</span> <span class="token punctuation">[</span><span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token hvariable">a</span> <span class="token operator">&lt;=</span> <span class="token hvariable">x</span><span class="token punctuation">]</span>
      <span class="token hvariable">biggerSorted</span> <span class="token operator">=</span> <span class="token hvariable">quicksort</span> <span class="token punctuation">[</span><span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token hvariable">a</span> <span class="token operator">&gt;</span> <span class="token hvariable">x</span><span class="token punctuation">]</span>
  <span class="token keyword">in</span> <span class="token hvariable">smallerSorted</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token hvariable">biggerSorted</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一步将 list 头部的元素，插入到两个 list 中间，smallerSorted 是小于等于 x 的元素组成的 list，biggerSorted 是比 x 大的元 素组成的 list。接着再对 smallerSorted，biggerSorted 进行递归。</p><p>若给 <code>[5,1,9,4,6,7,3]</code> 排序，这个算法就会取出它的头部，即 5。 将其置于分别比它大和比它小的两个 List 中间，得 <code>[1,4,3] ++ [5] ++ [9,6,7]</code>, 我们便知道了当排序结束之时，5 会在第四位，因为有 3 个数比它小，也有三个数比它大。好的，接着 排 <code>[1,4,3]</code> 与 <code>[9,6,7]</code>, 结果就出来了！</p><h4 id="collatz-串行" tabindex="-1"><a class="header-anchor" href="#collatz-串行" aria-hidden="true">#</a> Collatz 串行</h4><p>Collatz 串行：取一个自然数，若为偶数就除以 2。 若为奇数就乘以 3 再加 1。 再用相同的方式处理所得的结果，得到一组数字构成 的的链。它有个性质，无论任何以任何数字开始，最终的结果都会归 1。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token hvariable">chain</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Integral</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">chain</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token hvariable">chain</span> <span class="token hvariable">x</span>
		  <span class="token operator">|</span> <span class="token builtin">even</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">chain</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">`div`</span><span class="token number">2</span><span class="token punctuation">)</span>
		  <span class="token operator">|</span> <span class="token builtin">odd</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">chain</span> <span class="token punctuation">(</span><span class="token hvariable">n</span><span class="token operator">*</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="模块" tabindex="-1"><a class="header-anchor" href="#模块" aria-hidden="true">#</a> 模块</h3><p>Haskell 中使用 import 装载模块，<code>Prelude</code> 模块是缺省自动加载的。在 Haskell 中，装载模块必须得在函数的定义之前，所以一般 都是将它置于代码的顶部。一段代码中可以装载很多模块，只要将 <code>import</code> 语句分行写开即可。</p><p>例如，<code>import Data.List</code> 这样一来 <code>Data.List</code> 中包含的所有函数就都进入了全局命名空间。也就是说，你可以在代码的任意位置调 用这些函数.<code>Data.List</code> 模块中有个 <code>nub</code> 函数，它可以筛掉一个 List 中的所有重复元素。用点号将 <code>length</code> 和 <code>nub</code> 组合: <code>length . nub</code>，即可得到一个与 <code>(\xs -&gt; length (nub xs))</code> 等价的函数。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">numUniques</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">numUniques</span> <span class="token operator">=</span> <span class="token builtin">length</span> <span class="token operator">.</span> <span class="token hvariable">nub</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以只从模块中加载几个函数。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span> <span class="token punctuation">(</span><span class="token hvariable">nub</span><span class="token punctuation">,</span> <span class="token builtin">sort</span><span class="token punctuation">)</span> <span class="token comment">-- 这样就从 `Data.List` 加载了 nub，sort 两个函数</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上述导入都是直接导入到全局命名空间的，如果模块中的函数与全局中已有的函数冲突，就需要去掉冲突的函数。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List <span class="token keyword">hiding</span></span> <span class="token punctuation">(</span><span class="token hvariable">nub</span><span class="token punctuation">)</span> <span class="token comment">-- 这样就会不导入 nub，其余全部导入</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>也可以给新导入的模块增加命名空间：</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Data<span class="token punctuation">.</span>Map <span class="token keyword">as</span> M</span> <span class="token comment">-- as 用来重命名，默认命名空间即模块名 Data.Map</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="types-构造" tabindex="-1"><a class="header-anchor" href="#types-构造" aria-hidden="true">#</a> Types 构造</h3><p>Haskell 中允许用户自己定义类型，通过使用 <code>data</code> 关键字。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Replays</span> <span class="token operator">=</span> <span class="token string">&quot;Thanks&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;Fuck off&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>data</code> 后面跟的是类型名，= 右边是用 ｜拼接起来的“枚举值”，还记得 Haskell 中最重要的特性嘛，什么都是函数。所以这里的 &quot;Thanks&quot; 和 &quot;Fuck off&quot;，实际上就是函数，调用函数后就返回对应的值。Haskell 对这里的“枚举值”有特别的称呼，叫做<em>值构造子</em>。 型别名和值构造子的首字母必大写。</p><p>既然是函数就可以传递多个参数，比如说我们要描述一个人，可能会用名字，年龄，性别这些维度，Haskell 中就可以这样描述：</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Sex</span> <span class="token operator">=</span> <span class="token string">&quot;Male&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;Female&quot;</span> <span class="token comment">-- 这里定义一个性别类型</span>
<span class="token keyword">data</span> <span class="token constant">Person</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token constant">String</span> <span class="token constant">Int</span> <span class="token constant">Sex</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Person 类别中有一个值构造子，接受三个参数，类型分别是 String，Int，Sex（我们自己定义的，有两个可能 Male 和 Female）。对 于一个类，需要有一些基本的方法，例如需要知道这个 Person 的 name。这样就需要定义一些基本方法：</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token hvariable">name</span><span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">name</span> <span class="token punctuation">(</span><span class="token constant">Person</span> <span class="token hvariable">name</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">name</span> <span class="token comment">-- 通过模式匹配获取 name，实际上 Haskell 中的模式匹配，匹配的就是值构造子！！</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>仔细想想，上面的写法会有些让人疑惑，看到 Person 只知道需要几个参数，并不清楚参数什么意思，如果维度很多，大概会看着一大堆 的 String，Int... 发呆。</p><p>Haskell 也提供了一种更清晰的写法：</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Person</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span>
  <span class="token hvariable">name</span><span class="token operator">::</span> <span class="token constant">String</span><span class="token punctuation">,</span>
  <span class="token hvariable">age</span><span class="token operator">::</span> <span class="token constant">Int</span><span class="token punctuation">,</span>
  <span class="token hvariable">sex</span><span class="token operator">::</span> <span class="token constant">Sex</span>
<span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span> <span class="token comment">-- deriving 代表派生关系，例如 Show 就是将类型转化为 String，这样就可以打印到控制台</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的写法不仅更清楚，Haskell 还对这种 <em>Record Syntax</em> 的写法有额外支持，针对类型中的每个属性， Haskell 会自动生成上面 name 类似的方法。</p><p>有时候一个数据是什么类型，可能会有多种情况，例如常见的 <code>Maybe</code> 和 <code>Either</code>。可以参考 TS 中的 Promise，单纯的 Promise 不 是一个完整的类型，需要确定 Promise 中返回的类型。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Nothing</span> <span class="token operator">|</span> <span class="token constant">Just</span> <span class="token hvariable">a</span>
<span class="token keyword">data</span> <span class="token constant">Either</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">Left</span> <span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token constant">Right</span> <span class="token hvariable">b</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>类型定义中，也可以接受一个类别也可以接受一个参数（型别参数），有了型别参数，<code>Maybe</code> 就成为了一个型别构造子。<code>Maybe</code> 并不 是一个完整的类型，通过它可以构造出 <code>Maybe Int</code>，<code>Maybe String</code> 等诸多态别。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Just</span> <span class="token string">&quot;Haha&quot;</span>
<span class="token constant">Just</span> <span class="token string">&quot;Haha&quot;</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Maybe 只有成功情况才会传递数据，有时候判断成功与否都要做处理，就可以使用 Either。</p><p>一个例子：有个学校提供了不少壁橱，好给学生们地方放他们的 Gun&#39;N&#39;Rose 海报。每个壁橱都有个密码，哪个学生想用个壁橱，就告诉 管理员壁橱的号码，管理员就会告诉他壁橱的密码。但如果这个壁橱已经让别人用了，管理员就不能告诉他密码了，得换一个壁橱。我们 就用 <code>Data.Map</code> 的一个 Map 来表示这些壁橱，把一个号码映射到一个表示壁橱占用情况及密码的 Tuple 里。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Data<span class="token punctuation">.</span>Map <span class="token keyword">as</span> Map</span>

<span class="token keyword">data</span> <span class="token constant">LockerState</span> <span class="token operator">=</span> <span class="token constant">Taken</span> <span class="token operator">|</span> <span class="token constant">Free</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">)</span>

<span class="token keyword">type</span> <span class="token constant">Code</span> <span class="token operator">=</span> <span class="token constant">String</span> <span class="token comment">-- 这里使用了 type 重命名了 String 类型，是为了方便阅读</span>

<span class="token keyword">type</span> <span class="token constant">LockerMap</span> <span class="token operator">=</span> <span class="token constant">Map<span class="token punctuation">.</span>Map</span> <span class="token constant">Int</span> <span class="token punctuation">(</span><span class="token constant">LockerState</span><span class="token punctuation">,</span> <span class="token constant">Code</span><span class="token punctuation">)</span>

<span class="token hvariable">lockerLookup</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">LockerMap</span> <span class="token operator">-&gt;</span> <span class="token constant">Either</span> <span class="token constant">String</span> <span class="token constant">Code</span>
<span class="token hvariable">lockerLookup</span> <span class="token hvariable">lockerNumber</span> <span class="token builtin">map</span> <span class="token operator">=</span>
    <span class="token keyword">case</span> <span class="token constant">Map</span><span class="token punctuation">.</span><span class="token builtin">lookup</span> <span class="token hvariable">lockerNumber</span> <span class="token builtin">map</span> <span class="token keyword">of</span>  <span class="token comment">-- lookup 会返回一个 Maybe，成功代表已找到</span>
        <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Left</span> <span class="token operator">$</span> <span class="token string">&quot;Locker number &quot;</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">lockerNumber</span> <span class="token operator">++</span> <span class="token string">&quot; doesn&#39;t exist!&quot;</span>
        <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">state</span><span class="token punctuation">,</span> <span class="token hvariable">code</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">state</span> <span class="token operator">/=</span> <span class="token constant">Taken</span>
                                <span class="token keyword">then</span> <span class="token constant">Right</span> <span class="token hvariable">code</span>
                                <span class="token keyword">else</span> <span class="token constant">Left</span> <span class="token operator">$</span> <span class="token string">&quot;Locker &quot;</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">lockerNumber</span> <span class="token operator">++</span> <span class="token string">&quot; is already taken!&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="构造树" tabindex="-1"><a class="header-anchor" href="#构造树" aria-hidden="true">#</a> 构造树</h4><p>实现一个二叉搜索树 (binary search tree)。他的结构是每个节点指向两个其他节点，一个在左边一个在右边。在左边节点的元素会比 这个节点的元素要小。在右边的话则比较大。每个节点最多可以有两棵子树。譬如说一棵包含 5 的节点的左子树，里面所有的元素都会 小于 5。而节点的右子树里面的元素都会大于 5。如果我们想找找看 8 是不是在我们的树里面，我们就从 5 那个节点找起，由于 8 比 5 要大，很自然地就会往右搜索。接着我们走到 7，又由于 8 比 7 要大，所以我们再往右走。我们在三步就找到了我们要的元素。如果 这不是棵树而是 List 的话，那就会需要花到七步才能找到 8。</p><p>定义一个树的类型，不是一棵空的树就是带有值并含有两棵子树。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">EmptyTree</span> <span class="token operator">|</span> <span class="token constant">Node</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">)</span> <span class="token comment">-- Tree 是一个数据类型，这个类型递归调用了自身</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们不太想手动来建棵二叉搜索树，实现一个函数来完成，他接受一棵树还有一个元素，把这个元素安插到这棵二叉搜索树中。当拿这个 元素跟树的节点比较结果比较小的话，我们就往左走，如果比较大，就往右走。重复这个动作直到我们走到一棵空的树。一旦碰到空的树 的话，我们就把元素插入节点。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token hvariable">singleton</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token comment">-- 插入空树的操作</span>
<span class="token hvariable">singleton</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span>

<span class="token hvariable">treeInsert</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span>
<span class="token hvariable">treeInsert</span> <span class="token hvariable">x</span> <span class="token constant">EmptyTree</span> <span class="token operator">=</span> <span class="token hvariable">singleton</span> <span class="token hvariable">x</span> <span class="token comment">-- 如果是空树就插入</span>
<span class="token hvariable">treeInsert</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">a</span> <span class="token hvariable">left</span> <span class="token hvariable">right</span><span class="token punctuation">)</span> <span class="token comment">-- left 是传入树的左子树，right 是右子树</span>
      <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">left</span> <span class="token hvariable">right</span> <span class="token comment">-- 如果存在直接返回原有的树，存在不需要插入</span>
      <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">a</span>  <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token hvariable">treeInsert</span> <span class="token hvariable">x</span> <span class="token hvariable">left</span><span class="token punctuation">)</span> <span class="token hvariable">right</span> <span class="token comment">-- 小于就向左，递归查找左子树</span>
      <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token hvariable">a</span>  <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">a</span> <span class="token hvariable">left</span> <span class="token punctuation">(</span><span class="token hvariable">treeInsert</span> <span class="token hvariable">x</span> <span class="token hvariable">right</span><span class="token punctuation">)</span> <span class="token comment">-- 大于就向右，递归查找右子树</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>检查某个元素是否已经在这棵树中。判断和上面类似</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token hvariable">treeElem</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">treeElem</span> <span class="token hvariable">x</span> <span class="token constant">EmptyTree</span> <span class="token operator">=</span> <span class="token constant">False</span> <span class="token comment">-- 空树一定不包含所要查找元素</span>
<span class="token hvariable">treeElem</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">a</span> <span class="token hvariable">left</span> <span class="token hvariable">right</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">True</span> <span class="token comment">-- 相等即查找到元素</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">a</span>  <span class="token operator">=</span> <span class="token hvariable">treeElem</span> <span class="token hvariable">x</span> <span class="token hvariable">left</span> <span class="token comment">-- 小于向左递归查找</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token hvariable">a</span>  <span class="token operator">=</span> <span class="token hvariable">treeElem</span> <span class="token hvariable">x</span> <span class="token hvariable">right</span> <span class="token comment">-- 大于向右</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">nums</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">numsTree</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token hvariable">treeInsert</span> <span class="token constant">EmptyTree</span> <span class="token hvariable">nums</span> <span class="token comment">-- 从右向左 fold，所以 root 是 5</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">numsTree</span>
<span class="token constant">Node</span> <span class="token number">5</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">1</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">4</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">7</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">6</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">8</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="instance-typeclass" tabindex="-1"><a class="header-anchor" href="#instance-typeclass" aria-hidden="true">#</a> instance typeclass</h4><p>首先了解 <code>Eq</code> 这个 typeclass 的定义</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token keyword">class</span> <span class="token constant">Eq</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
    <span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token punctuation">(</span><span class="token operator">/=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token builtin">not</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">/=</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
    <span class="token hvariable">x</span> <span class="token operator">/=</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token builtin">not</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 a 是类型限定，也就是说只有统一类型的才可以进行 ==，/= 比较，这两种行为是互斥的。接下来定义一个 <code>Star</code> 类型，让它成 为 <code>Eq</code> 的 instace。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Star</span> <span class="token operator">=</span> <span class="token constant">Stella</span> <span class="token operator">|</span> <span class="token constant">Planet</span> <span class="token operator">|</span> <span class="token constant">Satellite</span>

<span class="token keyword">instance</span> <span class="token constant">Eq</span> <span class="token constant">Star</span> <span class="token keyword">where</span>
    <span class="token constant">Stella</span> <span class="token operator">==</span> <span class="token constant">Stella</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token constant">Planet</span> <span class="token operator">==</span> <span class="token constant">Planet</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token constant">Satellite</span> <span class="token operator">==</span> <span class="token constant">Satellite</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token hvariable">_</span> <span class="token operator">==</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">False</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用模式匹配，定义 Eq 中 == 的行为。==，/= 是互斥的，在 <code>Eq</code> 中也是相互定义的，这里只需要定义一种行为就行。上面的 instance 过程可以直接使用 derive 实现，如果需要定义特殊的表现，可以手动 instance。</p><p>有时在定义 class 需要做一定的限制（class constraints），例如 <code>Num</code> 的定义就要求必须要是 <code>Eq</code> 类型。这样 <code>Num</code> 就是一个 subclass，定义 <code>Num</code> 也不需要重复实现 <code>Eq</code> 的行为。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token keyword">class</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Num</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
   <span class="token operator">...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Maybe</code> 类型和 <code>Star</code> 又有区别，因为 <code>Maybe</code> 不是一个完整的类型，所以 instance 时需要额外的参数</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Eq</span> <span class="token punctuation">(</span><span class="token constant">Maybe</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
	<span class="token constant">Just</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token constant">Just</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span>
	<span class="token constant">Nothing</span> <span class="token operator">==</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token constant">True</span>
	<span class="token hvariable">_</span> <span class="token operator">==</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">False</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>m 代表任意类型，这样 Maybe m 就是一个类型了，需要判断是否相等，所以 m 需要是 Eq 类型。可以看出来定义依旧很清晰，简直就和 读文章一样，不需要太多的思考，Just x == Just y 和 x == y 结果相同，Nothing 相等，其余不相等。函数式编程就是这样，描述一 个问题，而不是去指导你怎么做。</p><h4 id="functor" tabindex="-1"><a class="header-anchor" href="#functor" aria-hidden="true">#</a> Functor</h4><p><code>Functor</code> 这个 typeclass，基本上就代表可以被 map over 的事物。听到这个词你可能会联想到 List，因为 map over list 在 Haskell 中是很常见的操作。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token keyword">class</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span> <span class="token comment">-- f 是类型，a -&gt; b 是对 f 中的数据进行映射，得到的还是一个映射后的 f 类型</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Functor</code> 中约束了一个 <code>fmap</code> 的行为，接受一个从一个型别映射到另一个型别的函数，还接受一个 functor 装有原始的型别（f a） ，然后会回传一个 functor 装有映射后的型别（f b）。可以看出来 f 是一个类别构造子，它接受一个参数，就像 <code>Maybe</code> 一样。</p><p>记得 <code>map</code> 的类型定义嘛： <code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>，这就是一个 fmap 的具体实现，List 也确实被定义成了 <code>Functor</code> 的 Instance。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token operator">=</span> <span class="token builtin">map</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>要想理解 <code>Functor</code>，需要对比思考一下，为什么要有这个类型。在 Haskell 中，简单的函数接受参数返回值，例如 <code>+ 3 4</code>，接受两 个参数 Int，返回一个 Int 值，或者更近一步 <code>(+ 3)</code> 这个函数，接受一个 Int 值，返回一个 Int 值。</p><p>但是对于 List 和 Maybe 呢，我们不能直接运用 <code>(+ 3)</code> ，因为两个类型都不一样。差别在于 Int 是一个类型，而 List 和 Maybe 是 一个带参数的类型，单独对 List 和 Maybe 做操作是没有意义的，也就是说直接操作缺少了一个参数。同时，数据结构是有意义的，对 List 和 Maybe 进行操作的时候，我们会希望继续保留这个结构。如果对一个 List 操作后，它会随机变成一种类型，想想你的代码怎么 写（有点夸张，但是好理解这样做的原理）？</p><p>自然也会想到提供一个函数接受那个缺少的类型，就能保证对类型中的元素进行操作是没问题的，例如 <code>map (+ 3) List::Int</code> 。这个 角度就能理解 <code>Functor</code> 的定义了，提供一个 fmap 函数，接受一个映射函数，然后对 <code>Functor</code> 的数据进行处理，并返回一个处理后 的 <code>Functor</code>，如对 list 中所有元素进行 <code>(+ 3)</code>。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Functor</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里注意理解 ，函数式编程中的 Typeclass 和面向对象中的 Class 的区别，Typeclass 更像一个集合，只是范畴特性上的描述，也就 意味着存在一个类型，即属于 Typeclass A 也属于 Typeclass B。面向对象的 class 则更实际，假设有一个 Dog 的 class，Dog 的实 例不可能同时也是另一个无关的 class（比如，Cat） 的实例。比如这里的 <code>fmap (replicate 3)</code> 接受一个任何型态的 functor，最终 返回一个数据类型是 list 的 functor，map 前后 functor 类型是一致的。</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Right</span> <span class="token string">&quot;blah&quot;</span><span class="token punctuation">)</span>
<span class="token constant">Right</span> <span class="token punctuation">[</span><span class="token string">&quot;blah&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;blah&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;blah&quot;</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Left</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span>
<span class="token constant">Left</span> <span class="token string">&quot;foo&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>与 群 有关的几个概念。</p><p>首先给定一个论域 A（也就是一个集合，一个定义域），再给定一个二元运算 *。</p><ol><li>若 *运算封闭，则成为 magma （ 原群）</li><li>若再 *运算满足结合律，则成为 semigroup （半群）</li><li>若再 存在单位元 e，则成为 monoid（含幺半群）</li><li>若再 任意元素存在逆元，则成为 group （群）</li></ol><p>\1. 若 *运算满足交换律，则成为 交换的，阿贝尔</p><p>半环、环</p><ol><li>环：加法成群，乘法是半群，并且加上加法和乘法的 compatible 条件，</li><li>半环：加法是半群，乘法也是半群，加上 compatible 条件。</li><li>最简单的例子是自然数，加法和乘法就是正常理解的加法和乘法，这个可能就是半环的来源。</li></ol></blockquote><p>可以针对 Functor 改进的地方，例如 <code>a -&gt; b</code> 也被包在一个 Functor value 里面呢？像是 <code>Just (*3)</code>，我们要如何 apply <code>Just 5</code> 给他？如果我们不要 apply <code>Just 5</code> 而是 <code>Nothing</code> 呢？甚至给定 <code>[(*2),(+4)]</code>，我们要如何 apply 他们到 <code>[1,2,3]</code> 呢？对于此，我们抽象出 <code>Applicative</code> typeclass，这就是我们想要问的问题：</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token punctuation">(</span><span class="token operator">&lt;*&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Applicative</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们也看到我们可以将一个正常的值包在一个数据型态中。例如说我们可以拿一个 <code>1</code> 然后把他包成 <code>Just 1</code>。或是把他包成 <code>[1]</code>。 也可以是一个 I/O action 会产生一个 <code>1</code>。这样包装的 function 我们叫他做 <code>pure</code>。</p><p>如我们说得，一个 applicative value 可以被看作一个有附加 context 的值。例如说，<code>&#39;a&#39;</code> 只是一个普通的字符，但 <code>Just &#39;a&#39;</code> 是 一个附加了 context 的字符。他不是 <code>Char</code> 而是 <code>Maybe Char</code>，这型态告诉我们这个值可能是一个字符，也可能什么都没有。</p><p>来看看 <code>Applicative</code> typeclass 怎样让我们用普通的 function 操作他们，同时还保有 context：</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">Just</span> <span class="token number">2</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token number">8</span>
<span class="token constant">Just</span> <span class="token number">16</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">Just</span> <span class="token string">&quot;klingon&quot;</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以我们可以视他们为 applicative values，<code>Maybe a</code> 代表可能会失败的 computation，<code>[a]</code> 代表同时有好多结果的 computation (non-deterministic computation)，而 <code>IO a</code> 代表会有 side-effects 的 computation。</p><p>Monad 是一个从 Applicative functors 很自然的一个演进结果。对于他们我们主要考量的点是：如果你有一个具有 context 的值 <code>m a</code>，你能如何把他丢进一个只接受普通值 <code>a</code> 的函数中，并回传一个具有 context 的值？也就是说，你如何套用一个型态为 <code>a -&gt; m b</code> 的函数至 <code>m a</code>？基本上，我们要求的函数是：</p><div class="language-haskell line-numbers-mode" data-ext="haskell"><pre class="language-haskell"><code><span class="token punctuation">(</span><span class="token operator">&gt;&gt;=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果我们有一个漂亮的值跟一个函数接受普通的值但回传漂亮的值，那我们要如何要把漂亮的值丢进函数中？这就是我们使用 Monad 时 所要考量的事情。我们不写成 <code>f a</code> 而写成 <code>m a</code> 是因为 <code>m</code> 代表的是 <code>Monad</code>，但 monad 不过就是支持 <code>&gt;&gt;=</code> 操作的 applicative functors。<code>&gt;&gt;=</code> 我们称呼他为 bind。</p></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: welkin105380@163.com">welkin</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--[--><div id="comment" class="giscus-wrapper input-top" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!--]--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/blog/assets/app-fdc7c009.js" defer></script>
  </body>
</html>
